# 学习型排序 文稿
排序算是计算机科学中最最基础的算法了。在数据库中也是常用的操作，包括对查询结果进行排序，作为连接的一部分或索引。
本文提出了一个新的方法，利用数据的经验CDF的学习模型的分布查询。



## 介绍
基于计数的排序算法，像基数排序，时间复杂度是O(wN)，w是key的长度，N是key的个数，对于小key通常是最快的算法。

基于比较的排序，像快速排序和归并排序，时间复杂度是O(NlogN)。

本文介绍一种机器学习赋能的排序算法。核心思想非常简单：对于要排序的keys A，先抽样，根据样本训练出一个CDF模型F，然后用F预测每个key的位置，得到了一个大致有序的输出数组，最后再对这个数据进行一次精确排序。

假设我们能训练出一个完美的经验CDF模型F，对于每一个key x经过F得到它的位置pos=F(x)*N，如果F是完美的，就意味着我们只需要O(N)的时间就可以进行一次排序。

几个挑战：
1. 最重要的一点，不可能建立一个完美的CDF模型。并且对CDF建模的最新的方法，尤其是神经网络，训练和执行起来都过于昂贵。
2. 就算已经有了一个完美的CDF模型，速度可能还是要慢于高度优化的基数排序算法，因为技术排序可以用完全的顺序写来实现，而这种原始的学习型排序会导致大量的随机写在把数据直接放到它有序的应有的位置上的时候。

本文给出了一个cache效率高的机器学习赋能的排序算法。下面来看具体是怎么实现的。

## 实现
一个完美的CDF模型可以一遍排序。如图一

但事实上不可能实现一个完美的CDF模型，尤其是用来建立模型的数据是抽样的。另外数据集中还可能有重复的数据，可能会导致多个key映射到同一个位置。

下面给出了一个原始的学习型排序的算法，它对于不精确的模型已经有了鲁棒性，然后解释它为什么还是不行。

### 用不精确的模型进行排序
重复的key会导致被映射到同一地址。一些模型无法保证单调性，导致输出会有小的错位。也就是说对于key a<b, 可能出现F(a)>F(b)的情况，导致输出不是有序的。这样的话最后就需要纠正这些错误。所以学习型算法需要解决以下问题：
1. 纠正非单调模型的错误
2. 处理key的冲突
3. 减少冲突

然后给了伪代码，解释

下面给出了一些解决冲突的方法，也是在哈希中经常用到的
1. 线性探测：随着数据的填入，探测越来越远，效率会越来越差
2. 链地址法：需要跟踪指针和动态分配内存，影响效率
3. 溢出桶：所有冲突的都放到一个桶中，需要桶内排序和最后的合并

经过试验比较，发现溢出桶的性能最好。

对于不单调的模型，最后的排序用的是插入排序：1.错位的元素很少 2.离正确的位置很近

从算法1中可知，模型的质量决定了冲突的数量，而冲突又极大的影响性能。而冲突的多少取决于模型有多好的过拟合数据。比如，假设我们训练出的CDF模型和我们用来产生数据分布的模型是一致的，冲突率也会有1/e，36.7%，这是独立于分布的。这遵循了生日悖论，和哈希表冲突类似。但是过拟合还是能够减少大量冲突。但是如果为了减少训练成本基于抽样训练出这个一个模型，是不可能训练出这样一个完美的经验CDF的。

这里有一个权衡就是：过拟合（低冲突）和训练成本（抽样）

算法1类似哈希表，CDF模型F<sub>A</sub>是哈希表中保序的哈希函数。 但是就算是零开销的CDF模型，算法1还是比基数排序慢。主要原因在于算法1的随机的和不可预测的数组访问会验证影响CPU cache和TLB的局部性，导致大量的stall。而cache优化的基数排序是内存访问优化的，主要是连续的内存访问。

### Cache优化的学习型排序
sljdfalskdjf
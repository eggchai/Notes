# 渐进索引： 为交互数据分析的索引
旧瓶装新酒，只是把原来的自适应索引扩展应用范围而已，扩展到数据仓库的数据分析中去——看完论文觉得还是不止如此的，本文提出了一些关于first query的问题，希望减少从原始列到复制列(索引列)的代价，所以是每次往索引列中填一部分。

在大数据时代，交互式数据探索和交互式数据分析变得越来越普遍，数据科学家尝试从大型不透明的数据集中提取有用的信息。这对传统的数据库系统提出了挑战：1.提前对查询负载一无所知 2.查询工作负载一直在变化 3.系统需要对提出的查询提供交互式响应。


## 介绍

索引面临的总的挑战：1.对查询负载一无所知(这样我们就不直到需要对那个属性建立索引)； 2.查询工作负载的变化； 3.对查询做出立即的响应（是说先建立索引再查询的巨大代价）

索引创建很难决策。根据预期的工作负载，DBA需要决定创建和维护特定的索引是否值得。探索和交互查询下是否要进行提前建立索引更是如此。以及不确定创建索引是否值得投资，无法确定是否会频繁查询此列使得创建完整索引的初期巨额投资能否取得回报。

尽管有以上挑战，索引对数据库仍然至关重要。没有索引存在时，简单的点查询和范围查询仍需要全表扫描。只要有两种策略来释放DBA必须手动创建索引：
+ 自动索引选择技术：在给定查询工作负载的情况下尝试找到最佳的索引集来实现。同时考虑拥有索引的好处和创建索引的额外成本。这需要事先了解预期的工作负载。
+ 自适应索引：如Database Cracking是更有前景的解决方案。自动的递增的建立索引作为查询的副产物。查询越多，索引越细化，直到最终达到完整的索引。这样创建索引的成本将被查询平摊掉，初始开销比较小。但是由于只在工作负载针对的区域进行了索引细化，因此无法保证收敛到完整索引。当查询到那些还没有优化的区域性能会降低，使得工作负载改变时导致性能峰值。

这里在自适应索引的基础上提出了一个新的增量索引技术：渐进索引。和前面的自适应索引的主要区别在于**控制索引预算**，是指从原始列到索引列的复制(分区)不是一蹴而就的，而是每次查询就复制过来一些。索引预算的控制上提供了两种方式，固定的和自适应的。

## 相关工作
自动索引的创建和维护是一个棘手且长期存在的问题。即使在一直工作模式的情况下，选择最佳索引集也是一个NP难问题。如果事先未知查询模式，不可能创建最佳的先验索引。自动索引分为两类，自动索引选择和自适应索引。

自动索引选择只适用于系统 工作负载已知且稳定的情况。在工作负载未知或快速变化的环境中，自动索引选择技术无法提供太多帮助。

而自适应索引是先验索引创建的替代方案。

Database Cracking的问题：
1. 第一次迭代的扫描显著增加了开销
2. cracking的性能不强健，工作负载的改变会导致性能峰值
3. 向完整索引的收敛依赖于工作负载
   
在改进的方向上有 更好的收敛，可预测的性能，更好的元组重构，更好的CPU利用率，其他的Crack引擎，预测查询处理和处理更新。下面就不再介绍了。

## 渐进索引
特征：
1. 每个查询的开销是可控的，时间上和空间上
2. 健壮的性能，与数据分布和查询分布无关的收敛
3. 索引预算可以动态调整，贵的查询可以少用点时间构建索引，便宜的查询可以多点时间构建索引
   
初始成本很低，不会出现自适应索引最坏的情况——就是只查询几次导致前期的拷贝分区的成本无法收回。

查询分为三个阶段，分别是创建，优化和巩固。每个阶段都是掺着查询，除了每次的查询，用可控制的代价来额外的构建索引。

**创建阶段**是渐进的构建出一个粗粒度的索引，每次查询都从原始列加N*δ个元素到索引列中。所以这时候查询也分为三步：1.在索引内查找；2.从还没有索引到的1-ρ部分进行查找(原始列部分)；3.（这时候已经得到了这个查询的结果）在把δ数据加入到索引列中。

**优化阶段**在原始列所有的数据都加入到索引列之后开始优化阶段。之后查询都在索引列上进行。在查询的过程中继续优化索引，直至收敛到完全有序。（这里说是优化进程优化完这一部分优化下一部分，但可能还是需要Cracker index，还不确定）

**巩固阶段**索引列完全有序之后开始建立一个完全B+树，因为B+树比二分查找有更好的数据局部性。当B+树完成之后用这个B+树来回答后续的查询。

**索引预算** δ决定了需要多少次查询来构建索引(Partition之间有序的索引列，可以看作是一个粗粒度索引)。

下面介绍四种渐进索引算法：快排，MSD，桶排序和LSD。(LSD就是凑数的，排序速度上比不上MSD，又对范围查询毫无用处)。


### 渐进式快排
创建阶段，分配和原始列同样大小的未初始化列（空的，索引列）。
在分块的支点(快排用来分块的中间值)与查询谓词无关，是另选的，可以是最大最小值的平均，如果有统计信息的话，也可以是中值。每次查询都把N*δ个数据从原始列从前到后放到索引列上，直到结束。

创建阶段的代价分为三部分 1.基表的扫描(获取查询结果) 2.索引列的查找(获取查询结果) 3.额外的索引时间(得到查询结果后还要N*δ条数据从基表拷贝到索引列)。
代价这部分比较好理解，公式难写，看论文吧


优化阶段：递归的，持续的原地快排，在不同的段之间围绕支点交换元素。当一个段被完全排序后，开始排序下一个段。用一个二叉树来记录支点。在索引列上查询的时候从这个二叉树先找到相应的段，然后进行扫描。当节点小于L1缓存时，对它进行完全排序。

巩固阶段：每β个元素就复制到父节点一个。构建一个完全B+树。

### 渐进式基数排序(MSD)
由高位到低位的基数排序。

创建阶段：b个桶，根据每个元素的前log<sub>2</sub>b位放入相应的桶中。基数划分有随机写的问题，不像前面的快排，只有两个地址，从前写和从后写。为了防止过量的Cache和TLB miss，假设每个桶的大小是一个内存页，b个桶，随机访问内存页的数量不应该超过cache line和TLB entries的数量。这里文中用的是512 L1 cache line和64 TLB entries，所以用了b=64。（这里需要补上TLB的知识）。
为了避免给每个桶分配过大的空间(因为如果没有事先遍历过数据是不知道每个桶里究竟有多少数据的)，这里用的是内存块链表。当一个块满的时候就把它加入对应桶的链表中去。

优化：用下一组log<sub>2</sub>b继续进行往下基数排序。为了避免桶太小导致维护桶的代价已经超过划分的代价，当桶能放进L1 Cache中就不再用基数排序持续的partition了，而是直接排序然后插入到索引列中相应的位置。用一个树来track桶，其中的节点指向中间桶，或者是指向最终索引列的某个位置。

### 桶排序
和前面的MSD的区别在于，这里的桶是按范围分的，每个桶的大小是等大的。代价会更高，通过扫描或者在第一次查询。